const socket = io(); let localStream; let peerConnection; const localVideo =
document.getElementById('localVideo'); const remoteVideo =
document.getElementById('remoteVideo'); const statusText =
document.getElementById('status'); // WebRTC Configuration const configuration =
{ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }; socket.on('connect',
() => { statusText.textContent = 'Connected. Waiting for a partner...'; }); //
Handle ICE Candidate from Server socket.on('ice-candidate', candidate => {
peerConnection.addIceCandidate(new RTCIceCandidate(candidate)); }); // Handle
Offer from Server socket.on('offer', async offer => {
peerConnection.setRemoteDescription(new RTCSessionDescription(offer)); const
answer = await peerConnection.createAnswer(); await
peerConnection.setLocalDescription(answer); socket.emit('answer', answer); });
// Handle Answer from Server socket.on('answer', answer => {
peerConnection.setRemoteDescription(new RTCSessionDescription(answer)); }); //
Start Call async function startCall() { statusText.textContent = 'Starting
call...'; localStream = await navigator.mediaDevices.getUserMedia({ video: true,
audio: true }); localVideo.srcObject = localStream; createPeerConnection();
const offer = await peerConnection.createOffer(); await
peerConnection.setLocalDescription(offer); socket.emit('offer', offer); } // End
Call function endCall() { peerConnection.close();
localStream.getTracks().forEach(track => track.stop()); statusText.textContent =
'Call ended.'; socket.disconnect(); } // Create WebRTC Peer Connection function
createPeerConnection() { peerConnection = new RTCPeerConnection(configuration);
peerConnection.ontrack = event => { remoteVideo.srcObject = event.streams[0]; };
peerConnection.onicecandidate = event => { if (event.candidate) {
socket.emit('ice-candidate', event.candidate); } };
localStream.getTracks().forEach(track => peerConnection.addTrack(track,
localStream)); }
